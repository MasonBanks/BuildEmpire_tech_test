import DS from 'ember-data';
// TODO aside from .data(), key vs. id, metadata, and subcollection this is basicly realtime-database, should refactor to reuse
export default class FirestoreSerializer extends DS.JSONSerializer {
    normalizeSingleResponse(store, primaryModelClass, payload, _id, _requestType) {
        if (!payload.exists) {
            throw new DS.NotFoundError();
        }
        const meta = extractMeta(payload);
        return Object.assign({}, normalize(store, primaryModelClass, payload), { meta });
    }
    normalizeArrayResponse(store, primaryModelClass, payload, _id, _requestType) {
        const normalizedPayload = payload.docs.map(snapshot => normalize(store, primaryModelClass, snapshot));
        const included = new Array().concat(...normalizedPayload.map(({ included }) => included));
        const meta = extractMeta(payload);
        const data = normalizedPayload.map(({ data }) => data);
        return { data, included, meta };
    }
}
export const normalize = (store, modelClass, snapshot) => {
    const id = snapshot.id;
    const type = modelClass.modelName;
    const _ref = snapshot.ref;
    const attributes = Object.assign({}, snapshot.data(), { _ref });
    const { relationships, included } = normalizeRelationships(store, modelClass, attributes);
    const data = { id, type, attributes, relationships };
    return { data, included };
};
function isQuerySnapshot(arg) {
    return arg.query !== undefined;
}
const extractMeta = (snapshot) => {
    if (isQuerySnapshot(snapshot)) {
        const query = snapshot.query;
        return Object.assign({}, snapshot.metadata, { query });
    }
    else {
        return snapshot.metadata;
    }
};
const normalizeRelationships = (store, modelClass, attributes) => {
    const relationships = {};
    const included = [];
    modelClass.eachRelationship((key, relationship) => {
        const attribute = attributes[key];
        delete attributes[key];
        relationships[key] = normalizeRealtionship(relationship)(store, attribute, relationship, included);
    }, null);
    return { relationships, included };
};
const normalizeRealtionship = (relationship) => {
    if (relationship.kind === 'belongsTo') {
        return normalizeBelongsTo;
    }
    else if (relationship.options.subcollection) {
        return normalizeHasMany; // this is handled in the adapter
    }
    else if (relationship.options.embedded) {
        return normalizeEmbedded;
    }
    else {
        return normalizeHasMany;
    }
};
const normalizeBelongsTo = (_store, id, relationship, _included) => {
    if (id) {
        return { data: { id, type: relationship.type } };
    }
    else {
        return {};
    }
};
const normalizeEmbedded = (store, attribute, relationship, included) => {
    if (attribute) {
        Object.keys(attribute).forEach(id => {
            const val = attribute[id];
            const snapshot = { id, data: () => val };
            const model = store.modelFor(relationship.type);
            const { data, included: includes } = normalize(store, model, snapshot);
            included.push(data);
            includes.forEach((record) => included.push(record));
        });
        const data = included
            .filter(record => record.type == relationship.type)
            .map(record => ({ id: record.id, type: record.type }));
        return { links: { related: 'emberfire' }, data };
    }
    else {
        return {};
    }
};
const normalizeHasMany = (_store, _attribute, _relationship, _included) => ({ links: { related: 'emberfire' } });
